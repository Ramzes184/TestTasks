#План

#Подготовления

У пользователей приложения возможны только 3 роли (READ, WRITE, EXECUTE) -> введем enum тих ролей
Сведения о ролях соответсвующим конкретным пользователям должны храниться в отдельном файле или sql-таблице
В отдельном файле или sql-таблице хранится логины и хэшированные пароли пользователей, а так же сгенерированные при регистрации соли
Для удобной работы с пользователями создадим класс User, хранящий логин, хэшированный пароль и роль

#Аутентификация (R1.1)

Для авторизации создадим класс IdentityProvider, использующий для извлечения данных из источника userdata.Service.
Provider сравнивает введеные пользователем данные с найдеными в базе. Возможные ошибки:
пользователя с таким логином не существует (exit code 3)
пароль для указанного логина не верный (exit code 4)
При запросе на аутентификацию Provider отправляет в userdata.Service запрос на поиск учетки с указанным логином в базе данных.
Если такого пользователя в базе нет, выбрасываем первую ошибку (см выше), иначе хэшируем введенный пароль и сравниваем с полученным userdata.Service-ом.
При успешной аутентификации производим авторизацию, иначе выбрасываем вторую ошибку.

#Хранение пароля (R1.2)

Для хэширования используем уже реализованный java.security.MessageDigest
Соли генерируюся случайным образом при регистрации и хранятся вместе с логином и паролем

#Авторизация (R1.3)

Для авторизации создадим AuthorityProvider, использующий userdata.Service для доступа к данным ролей пользователей
После успешной работы IdentityProvider-а AuthorityProvider передает запрос в свой userdata.Service запрос на поиск ролей пользователя.
После успешной авторизации свойство role в узера устанавливается.